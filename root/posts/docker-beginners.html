<h1>Docker for Beginners</h1>

<p>Docker has revolutionized the way we develop, deploy, and run applications. This comprehensive guide will help you understand Docker and start containerizing your applications.</p>

<h2>What is Docker?</h2>

<p>Docker is a platform that enables developers to package applications and their dependencies into lightweight, portable containers. These containers can run consistently across different environments, from your local machine to production servers.</p>

<h3>Why Use Docker?</h3>

<ul>
    <li><strong>Consistency</strong> - "It works on my machine" becomes a thing of the past</li>
    <li><strong>Isolation</strong> - Applications run in isolated environments without conflicts</li>
    <li><strong>Portability</strong> - Run the same container anywhere Docker is installed</li>
    <li><strong>Efficiency</strong> - Containers are lightweight and start quickly</li>
    <li><strong>Scalability</strong> - Easy to scale applications horizontally</li>
</ul>

<h2>Installing Docker</h2>

<p>Download and install Docker Desktop from the official website:</p>

<pre><code># Verify installation
docker --version
docker run hello-world</code></pre>

<h2>Core Concepts</h2>

<h3>Images</h3>
<p>Docker images are read-only templates that contain the application code, runtime, libraries, and dependencies. They serve as blueprints for creating containers.</p>

<h3>Containers</h3>
<p>Containers are running instances of Docker images. They're isolated processes that run on the host operating system.</p>

<h3>Dockerfile</h3>
<p>A Dockerfile is a text file containing instructions for building a Docker image.</p>

<h2>Your First Dockerfile</h2>

<p>Let's create a simple Dockerfile for a Node.js application:</p>

<pre><code># Use an official Node runtime as base image
FROM node:18-alpine

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy application code
COPY . .

# Expose port
EXPOSE 3000

# Define the command to run the app
CMD ["node", "server.js"]</code></pre>

<h2>Essential Docker Commands</h2>

<h3>Working with Images</h3>

<pre><code># Build an image
docker build -t myapp:1.0 .

# List images
docker images

# Remove an image
docker rmi image_name

# Pull an image from Docker Hub
docker pull nginx:latest</code></pre>

<h3>Working with Containers</h3>

<pre><code># Run a container
docker run -d -p 8080:80 --name mycontainer nginx

# List running containers
docker ps

# List all containers
docker ps -a

# Stop a container
docker stop mycontainer

# Start a stopped container
docker start mycontainer

# Remove a container
docker rm mycontainer

# View container logs
docker logs mycontainer

# Execute command in running container
docker exec -it mycontainer /bin/bash</code></pre>

<h2>Docker Compose</h2>

<p>Docker Compose allows you to define and run multi-container applications. Create a <code>docker-compose.yml</code> file:</p>

<pre><code>version: '3.8'

services:
  web:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    depends_on:
      - db

  db:
    image: postgres:14
    environment:
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: myapp
    volumes:
      - db-data:/var/lib/postgresql/data

volumes:
  db-data:</code></pre>

<p>Run with Docker Compose:</p>

<pre><code># Start all services
docker-compose up -d

# Stop all services
docker-compose down

# View logs
docker-compose logs -f</code></pre>

<h2>Best Practices</h2>

<ol>
    <li><strong>Use official base images</strong> - Start with trusted, well-maintained images</li>
    <li><strong>Keep images small</strong> - Use alpine variants when possible</li>
    <li><strong>Leverage layer caching</strong> - Order Dockerfile instructions to maximize cache hits</li>
    <li><strong>Use .dockerignore</strong> - Exclude unnecessary files from your image</li>
    <li><strong>Don't run as root</strong> - Create a non-root user for security</li>
    <li><strong>Use environment variables</strong> - Keep configuration flexible</li>
    <li><strong>One process per container</strong> - Follow the single responsibility principle</li>
</ol>

<h2>Common Use Cases</h2>

<h3>Development Environment</h3>
<p>Create consistent development environments across your team without installing dependencies locally.</p>

<h3>Microservices Architecture</h3>
<p>Run multiple services independently, each in its own container.</p>

<h3>Continuous Integration/Deployment</h3>
<p>Build, test, and deploy applications in containerized environments.</p>

<h2>Troubleshooting Tips</h2>

<pre><code># Check container resource usage
docker stats

# Inspect container details
docker inspect mycontainer

# Remove all stopped containers
docker container prune

# Remove unused images
docker image prune -a

# View disk usage
docker system df</code></pre>

<h2>Conclusion</h2>

<p>Docker simplifies application deployment and makes your development workflow more efficient. Start by containerizing a simple application, then gradually explore more advanced features like Docker Compose, volumes, and networking.</p>

<p>The investment in learning Docker pays off quickly as you'll spend less time dealing with environment inconsistencies and more time building great software!</p>
